#!/usr/bin/env python

import logging
from argparse import ArgumentParser
import subprocess

logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s %(message)s')


def main():
    parser = ArgumentParser(description='Scrub remote deleted branches from local and remote tracking branches.')
    parser.add_argument('remote', nargs='?', help='Specify the remote [origin]')

    args = parser.parse_args()

    remote = args.remote or 'origin'

    delete_all = False

    branches, _ = call_command('git remote prune %s' % remote)
    branches = branches.splitlines()

    for branch in branches:
        branch = branch.strip()

        if branch.startswith('*'):
            print branch
            branch = branch.replace('* [pruned] %s/' % remote, '')

            logging.debug('branch: %s' % branch)

            stdout, stderr = call_command('git branch -d %s' % branch)
            print stdout

            if 'not fully merged' in stderr:
                if delete_all is True:
                    delete_local_branch(branch)
                else:
                    print stderr.splitlines()[0]
                    override = raw_input('Delete %s branch with prejudice? (Y, N, A)' % branch)
                    if override in ['A', 'a']:
                        delete_all = True
                        delete_local_branch(branch)
                    elif override in ['Y', 'y']:
                        delete_local_branch(branch)
                    else:
                        print '%s branch skipped' % branch


def delete_local_branch(branch):
    stdout, stderr = call_command('git branch -D %s' % branch)
    print stdout


def call_command(command):
    process = subprocess.Popen(command.split(' '), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return process.communicate()


if __name__ == "__main__":
    main()
