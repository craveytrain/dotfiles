# Architecture: ansible-role-dotmodules Integration

**Research Date**: 2026-01-23
**Context**: Adding new configuration modules (Ghostty, Claude) to existing dotfiles system
**Focus**: Integration patterns, not system re-architecture

## Executive Summary

New modules integrate into ansible-role-dotmodules through a simple, declarative pattern: create a directory in `modules/` with `config.yml` defining dependencies and `files/` containing dotfiles. The role handles package installation, file merging, and symlink deployment automatically. No custom Ansible tasks required for standard modules.

## Component Architecture

### Module Directory Structure

Each module is a self-contained package with this structure:

```
modules/module-name/
├── config.yml              # Module metadata (REQUIRED)
├── files/                  # Dotfiles to deploy (REQUIRED)
│   ├── .config/           # XDG config files
│   ├── .dotfile           # Home directory dotfiles
│   └── .local/bin/        # Scripts and binaries
└── README.md              # Documentation (RECOMMENDED)
```

**Integration Point**: ansible-role-dotmodules discovers modules via the `dotmodules.install` list in `playbooks/deploy.yml`.

### config.yml Schema

The `config.yml` file declares module dependencies and behavior.

#### Required Fields

**None** - An empty `config.yml` is valid, though not useful.

#### Optional Fields

| Field | Type | Purpose | Example |
|-------|------|---------|---------|
| `homebrew_packages` | List | CLI tools to install via Homebrew | `- git`, `- vim` |
| `homebrew_casks` | List | GUI apps to install via Homebrew | `- 1password-cli` |
| `stow_dirs` | List | Subdirectories in `files/` to symlink | `- git`, `- shell` |
| `mergeable_files` | List | Files contributed by multiple modules | `- '.zshrc'`, `- '.config/fish/config.fish'` |
| `register_shell` | String | Shell binary to register in `/etc/shells` | `fish`, `zsh` |

**Example - Simple module (Ghostty)**:
```yaml
---
# Minimal module: just deploy files
stow_dirs:
  - ghostty
```

**Example - Complex module (Zsh)**:
```yaml
---
# Full-featured module
homebrew_packages:
  - zsh
  - powerlevel10k
  - zsh-autosuggestions
  - zsh-syntax-highlighting

stow_dirs:
  - zsh

mergeable_files:
  - '.zshrc'
  - '.zsh/aliases.sh'
  - '.zsh/environment.sh'
```

### File Organization Patterns

#### Pattern 1: Home Directory Dotfiles

**Use case**: Traditional dotfiles (`.gitconfig`, `.vimrc`, etc.)

**Structure**:
```
modules/git/files/
└── .gitconfig              # Deploys to ~/.gitconfig
```

**Deployment**: Symlink created at `~/.gitconfig` → `~/.dotmodules/git/files/.gitconfig`

#### Pattern 2: XDG Config Directories

**Use case**: Modern config locations (`~/.config/app/`)

**Structure**:
```
modules/ghostty/files/
└── .config/
    └── ghostty/
        └── config          # Deploys to ~/.config/ghostty/config
```

**Deployment**: Symlink created at `~/.config/ghostty/config` → `~/.dotmodules/ghostty/files/.config/ghostty/config`

#### Pattern 3: Local Binaries

**Use case**: Custom scripts and tools

**Structure**:
```
modules/shell/files/
└── .local/
    └── bin/
        └── my-script       # Deploys to ~/.local/bin/my-script
```

**Deployment**: Symlink created at `~/.local/bin/my-script` → `~/.dotmodules/shell/files/.local/bin/my-script`

#### Pattern 4: Mergeable Configuration

**Use case**: Multiple modules contribute to single file (`.zshrc`, `.config/fish/config.fish`)

**Structure**:
```
modules/zsh/files/
└── .zsh/
    └── aliases.sh          # Partial contribution

modules/editor/files/
└── .zsh/
    └── aliases.sh          # Another contribution
```

**config.yml**:
```yaml
mergeable_files:
  - '.zsh/aliases.sh'
```

**Deployment**:
1. ansible-role-dotmodules concatenates all contributions
2. Adds module headers showing source
3. Writes merged file to `modules/merged/.zsh/aliases.sh`
4. Symlinks `~/.zsh/aliases.sh` → `~/.dotmodules/merged/.zsh/aliases.sh`

**Merged output**:
```bash
# Generated by ansible-role-dotmodules
# Merged from multiple modules on 2025-12-27T00:27:59Z

# =============================================================================
# ZSH MODULE CONTRIBUTION
# =============================================================================

alias ip="dig +short myip.opendns.com @resolver1.opendns.com"

# =============================================================================
# EDITOR MODULE CONTRIBUTION
# =============================================================================

alias e='${(z)VISUAL:-${(z)EDITOR}}'

# =============================================================================
# END OF MERGED CONTENT
# =============================================================================
```

## Integration with Existing Modules

### Module Dependencies

Modules can depend on other modules but dependencies are **not enforced** by ansible-role-dotmodules. Dependencies are documented and must be ordered correctly in `playbooks/deploy.yml`.

**Example - Node depends on dev-tools**:

```yaml
# modules/node/config.yml
# Prerequisites:
# - dev-tools module must be installed first (provides mise via Homebrew)

stow_dirs:
  - node

mergeable_files:
  - '.config/mise/config.toml'
```

```yaml
# playbooks/deploy.yml
dotmodules:
  install:
    - dev-tools   # MUST come before node
    - node        # Depends on mise from dev-tools
```

### Module Ordering

Order matters for:
1. **Dependencies**: Prerequisite modules must install first
2. **Merging**: Later modules can override earlier ones in merged files
3. **No other constraints**: Symlinks are independent

**Current order** (from `playbooks/deploy.yml`):
```yaml
install:
  - git           # No dependencies
  - fonts         # No dependencies
  - 1password     # No dependencies
  - shell         # No dependencies
  - fish          # No dependencies (fish shell)
  - zsh           # No dependencies (zsh shell)
  - dev-tools     # No dependencies (provides mise)
  - node          # Depends on dev-tools (uses mise)
  - editor        # No dependencies (vim)
```

### Shared Configuration Files

Multiple modules can contribute to the same configuration file via `mergeable_files`.

**Current shared files**:

| File | Contributors | Purpose |
|------|--------------|---------|
| `.zshrc` | zsh, dev-tools | Shell initialization |
| `.zsh/aliases.sh` | zsh, editor | Command aliases |
| `.zsh/environment.sh` | shell, zsh, editor | Environment variables |
| `.config/fish/config.fish` | fish, shell, dev-tools, editor | Fish shell config |
| `.config/mise/config.toml` | dev-tools, node | Tool version management |

**Pattern**:
1. Each module provides its section in `files/`
2. Declares file in `mergeable_files` list
3. ansible-role-dotmodules merges contributions
4. Merged file deployed to home directory

## Implementation Guidance

### Adding a Simple Module (Ghostty Example)

**Step 1: Create module structure**
```bash
mkdir -p modules/ghostty/files/.config/ghostty
```

**Step 2: Add config file**
```bash
# modules/ghostty/files/.config/ghostty/config
theme = dark
font-family = "Fira Code"
```

**Step 3: Create config.yml**
```yaml
---
# modules/ghostty/config.yml
stow_dirs:
  - ghostty
```

**Step 4: Add to playbook**
```yaml
# playbooks/deploy.yml
dotmodules:
  install:
    - ghostty  # Add to list
```

**Step 5: Deploy**
```bash
ansible-playbook -i playbooks/inventory playbooks/deploy.yml
```

**Result**: `~/.config/ghostty/config` → `~/.dotmodules/ghostty/files/.config/ghostty/config`

### Adding a Module with Dependencies (Claude Example)

**Scenario**: Claude CLI needs configuration but also shell aliases

**Step 1: Create module structure**
```bash
mkdir -p modules/claude/files/.config/claude
mkdir -p modules/claude/files/.zsh
```

**Step 2: Add Claude config**
```bash
# modules/claude/files/.config/claude/config.json
{
  "api_key": "set via ~/.config/claude/config.local.json",
  "model": "claude-sonnet-4-5"
}
```

**Step 3: Add shell aliases**
```bash
# modules/claude/files/.zsh/aliases.sh
alias c="claude"
alias ccode="claude --mode code"
```

**Step 4: Create config.yml**
```yaml
---
# modules/claude/config.yml
stow_dirs:
  - claude

mergeable_files:
  - '.zsh/aliases.sh'  # Merge with zsh and editor modules
```

**Step 5: Add to playbook (order matters for merging)**
```yaml
# playbooks/deploy.yml
dotmodules:
  install:
    - zsh       # Base aliases
    - editor    # Editor aliases
    - claude    # Claude aliases (merged last, can override)
```

**Result**:
- `~/.config/claude/config.json` → `~/.dotmodules/claude/files/.config/claude/config.json`
- `~/.zsh/aliases.sh` → `~/.dotmodules/merged/.zsh/aliases.sh` (includes Claude section)

### Adding a Module with Homebrew Packages

**Scenario**: Module needs to install software first

**config.yml**:
```yaml
---
homebrew_packages:
  - bat       # CLI tool
  - jq        # CLI tool

homebrew_casks:
  - visual-studio-code  # GUI app

stow_dirs:
  - dev-tools
```

**Deployment flow**:
1. ansible-role-dotmodules installs Homebrew packages
2. ansible-role-dotmodules installs Homebrew casks
3. Stow symlinks configuration files

### Shell Registration Pattern

**Use case**: Register custom shell in `/etc/shells` to allow `chsh`

**config.yml**:
```yaml
---
# modules/fish/config.yml
homebrew_packages:
  - fish

register_shell: fish  # Registers /opt/homebrew/bin/fish
```

**Deployment**:
```bash
# Requires sudo for /etc/shells modification
ansible-playbook -i playbooks/inventory playbooks/deploy.yml --ask-become-pass
```

**Skip registration** (CI/CD, restricted environments):
```bash
ansible-playbook -i playbooks/inventory playbooks/deploy.yml --skip-tags register_shell
```

**Auto-detection**: Shell path detected based on architecture:
- Apple Silicon: `/opt/homebrew/bin/fish`
- Intel: `/usr/local/bin/fish`

## Integration Points

### Entry Point: Playbook

**File**: `playbooks/deploy.yml`

**Role**: Orchestrates module processing

**Configuration**:
```yaml
---
- name: Deploy dotfiles using ansible-role-dotmodules
  hosts: localhost
  vars:
    dotmodules:
      repo: 'file://{{ playbook_dir }}/../modules'
      dest: '{{ ansible_env.HOME }}/.dotmodules'
      install:
        - git
        - ghostty  # Add new modules here
        - claude
  roles:
    - role: ansible-role-dotmodules
```

**Integration**: Add module name to `dotmodules.install` list.

### Processing: ansible-role-dotmodules

**Source**: External role from `https://github.com/craveytrain/ansible-role-dotmodules.git`

**Responsibilities**:
1. Read each module's `config.yml`
2. Install Homebrew packages/casks
3. Merge `mergeable_files` into `modules/merged/`
4. Run GNU Stow on `stow_dirs`
5. Register shells (if `register_shell` defined)

**Integration**: Transparent - no custom tasks required.

### Deployment: GNU Stow

**Role**: Create symlinks from `~/.dotmodules/` to home directory

**Behavior**:
- Mirrors directory structure from `files/` to `~/`
- Handles nested directories automatically
- Detects conflicts (existing non-symlink files)

**Integration**: Specify directories in `stow_dirs` list.

### Merging: Configuration Assembly

**Role**: Combine contributions from multiple modules

**Process**:
1. Collect all files matching `mergeable_files` from all modules
2. Concatenate in module order
3. Add headers showing source module
4. Write to `modules/merged/`
5. Symlink merged file to home directory

**Integration**: Declare files in `mergeable_files` list.

## Build Order Implications

### Suggested Implementation Order for New Modules

**Tier 1: Standalone modules** (no dependencies)
- Ghostty terminal config
- Fonts
- 1Password CLI
- Simple config-only modules

**Tier 2: Shell-integrated modules** (depend on shell modules existing)
- Modules contributing to `.zshrc` or `.config/fish/config.fish`
- Modules with shell aliases/functions

**Tier 3: Tool-dependent modules** (depend on other tools)
- Modules using mise (depend on dev-tools)
- Modules using custom binaries (depend on providing module)

**Tier 4: Complex modules** (multiple dependencies)
- Modules with both Homebrew packages AND mergeable files
- Modules requiring shell registration

### Deployment Considerations

**Idempotency**: Safe to run playbook multiple times
- Homebrew: Skips already-installed packages
- Stow: Re-creates symlinks (idempotent)
- Merging: Regenerates merged files (idempotent)

**Partial deployments**: Not supported - all modules in `install` list are processed

**Rollback**: Manual - remove module from list and re-run playbook (symlinks removed, packages remain)

## Quality Gates

### Components Clearly Defined

- **Module**: Self-contained directory in `modules/` with `config.yml` and `files/`
- **config.yml**: Declarative YAML defining dependencies and behavior
- **files/**: Directory tree mirroring home directory structure
- **Merged module**: Special module containing merged configuration output
- **ansible-role-dotmodules**: External Ansible role processing modules
- **GNU Stow**: Symlink deployment tool

**Boundaries**:
- Modules are independent (no shared state except merged files)
- ansible-role-dotmodules owns processing logic (modules are pure data)
- Merging is one-way (modules contribute, don't modify merged output)

### Integration Points Explicit

1. **Playbook → ansible-role-dotmodules**: `dotmodules.install` list
2. **ansible-role-dotmodules → Modules**: Reads `config.yml` from each module
3. **ansible-role-dotmodules → Homebrew**: Installs packages/casks
4. **ansible-role-dotmodules → Merging**: Concatenates `mergeable_files`
5. **ansible-role-dotmodules → Stow**: Symlinks `stow_dirs`
6. **Merged files → Home directory**: Stow symlinks merged output
7. **Local overrides → Applications**: `.*.local` files loaded at runtime

### Build Order Noted

**Critical dependencies**:
- `dev-tools` MUST come before `node` (provides mise)
- Modules with `mergeable_files` ordered by override priority (later = higher)
- Shell modules (`fish`, `zsh`) before modules contributing to shell config

**Non-critical ordering**:
- Standalone modules (Ghostty, 1Password) can be anywhere
- Font modules independent

**Current order** (verified working):
```
git → fonts → 1password → shell → fish → zsh → dev-tools → node → editor
```

**Suggested order for new modules**:
```
[standalone modules] → [shell modules] → [tool providers] → [tool consumers] → [integrations]
```

## References

**Existing modules analyzed**:
- `modules/git/` - Simple stow-only module
- `modules/zsh/` - Complex module with packages, merging, shell registration
- `modules/node/` - Dependent module (requires dev-tools)
- `modules/editor/` - Module with mergeable contributions

**Key files reviewed**:
- `playbooks/deploy.yml` - Deployment orchestration
- `modules/*/config.yml` - Module metadata (9 modules)
- `modules/merged/` - Merged output examples
- `README.md` - User documentation
- `.planning/codebase/ARCHITECTURE.md` - System architecture

**External dependencies**:
- ansible-role-dotmodules: https://github.com/craveytrain/ansible-role-dotmodules.git
- GNU Stow documentation
- Ansible 2.9+ documentation

---

**Analysis completed**: 2026-01-23
**Next step**: Use this architecture to inform phase structure in roadmap development
